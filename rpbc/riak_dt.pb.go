// Code generated by protoc-gen-gogo.
// source: riak_dt.proto
// DO NOT EDIT!

/*
	Package rpbc is a generated protocol buffer package.

	It is generated from these files:
		riak_dt.proto

	It has these top-level messages:
		MapField
		MapEntry
		DtFetchReq
		DtValue
		DtFetchResp
		CounterOp
		SetOp
		MapUpdate
		MapOp
		DtOp
		DtUpdateReq
		DtUpdateResp
*/
package rpbc

import proto "code.google.com/p/gogoprotobuf/proto"
import math "math"

// discarding unused import gogoproto "gogo.pb"
// discarding unused import rpbc1 "riak.pb"

import io1 "io"
import fmt1 "fmt"
import code_google_com_p_gogoprotobuf_proto1 "code.google.com/p/gogoprotobuf/proto"

import bytes1 "bytes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

//
// The types that can be stored in a map are limited to counters,
// sets, registers, flags, and maps.
type MapField_MapFieldType int32

const (
	MapField_COUNTER  MapField_MapFieldType = 1
	MapField_SET      MapField_MapFieldType = 2
	MapField_REGISTER MapField_MapFieldType = 3
	MapField_FLAG     MapField_MapFieldType = 4
	MapField_MAP      MapField_MapFieldType = 5
)

var MapField_MapFieldType_name = map[int32]string{
	1: "COUNTER",
	2: "SET",
	3: "REGISTER",
	4: "FLAG",
	5: "MAP",
}
var MapField_MapFieldType_value = map[string]int32{
	"COUNTER":  1,
	"SET":      2,
	"REGISTER": 3,
	"FLAG":     4,
	"MAP":      5,
}

func (x MapField_MapFieldType) Enum() *MapField_MapFieldType {
	p := new(MapField_MapFieldType)
	*p = x
	return p
}
func (x MapField_MapFieldType) String() string {
	return proto.EnumName(MapField_MapFieldType_name, int32(x))
}
func (x *MapField_MapFieldType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MapField_MapFieldType_value, data, "MapField_MapFieldType")
	if err != nil {
		return err
	}
	*x = MapField_MapFieldType(value)
	return nil
}

type DtFetchResp_DataType int32

const (
	DtFetchResp_COUNTER DtFetchResp_DataType = 1
	DtFetchResp_SET     DtFetchResp_DataType = 2
	DtFetchResp_MAP     DtFetchResp_DataType = 3
)

var DtFetchResp_DataType_name = map[int32]string{
	1: "COUNTER",
	2: "SET",
	3: "MAP",
}
var DtFetchResp_DataType_value = map[string]int32{
	"COUNTER": 1,
	"SET":     2,
	"MAP":     3,
}

func (x DtFetchResp_DataType) Enum() *DtFetchResp_DataType {
	p := new(DtFetchResp_DataType)
	*p = x
	return p
}
func (x DtFetchResp_DataType) String() string {
	return proto.EnumName(DtFetchResp_DataType_name, int32(x))
}
func (x *DtFetchResp_DataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DtFetchResp_DataType_value, data, "DtFetchResp_DataType")
	if err != nil {
		return err
	}
	*x = DtFetchResp_DataType(value)
	return nil
}

//
// Flags only exist inside Maps and can only be enabled or
// disabled, and there are no arguments to the operations.
type MapUpdate_FlagOp int32

const (
	MapUpdate_ENABLE  MapUpdate_FlagOp = 1
	MapUpdate_DISABLE MapUpdate_FlagOp = 2
)

var MapUpdate_FlagOp_name = map[int32]string{
	1: "ENABLE",
	2: "DISABLE",
}
var MapUpdate_FlagOp_value = map[string]int32{
	"ENABLE":  1,
	"DISABLE": 2,
}

func (x MapUpdate_FlagOp) Enum() *MapUpdate_FlagOp {
	p := new(MapUpdate_FlagOp)
	*p = x
	return p
}
func (x MapUpdate_FlagOp) String() string {
	return proto.EnumName(MapUpdate_FlagOp_name, int32(x))
}
func (x *MapUpdate_FlagOp) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MapUpdate_FlagOp_value, data, "MapUpdate_FlagOp")
	if err != nil {
		return err
	}
	*x = MapUpdate_FlagOp(value)
	return nil
}

//
// Field names in maps are composed of a binary identifier and a type.
// This is so that two clients can create fields with the same name
// but different types, and they converge independently.
type MapField struct {
	Name             []byte                 `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Type             *MapField_MapFieldType `protobuf:"varint,2,req,name=type,enum=rpbc.MapField_MapFieldType" json:"type,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *MapField) Reset()         { *m = MapField{} }
func (m *MapField) String() string { return proto.CompactTextString(m) }
func (*MapField) ProtoMessage()    {}

func (m *MapField) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *MapField) GetType() MapField_MapFieldType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return MapField_COUNTER
}

//
// An entry in a map is a pair of a field-name and value. The type
// defined in the field determines which value type is expected.
type MapEntry struct {
	Field            *MapField   `protobuf:"bytes,1,req,name=field" json:"field,omitempty"`
	CounterValue     *int64      `protobuf:"zigzag64,2,opt,name=counter_value" json:"counter_value,omitempty"`
	SetValue         [][]byte    `protobuf:"bytes,3,rep,name=set_value" json:"set_value,omitempty"`
	RegisterValue    []byte      `protobuf:"bytes,4,opt,name=register_value" json:"register_value,omitempty"`
	FlagValue        *bool       `protobuf:"varint,5,opt,name=flag_value" json:"flag_value,omitempty"`
	MapValue         []*MapEntry `protobuf:"bytes,6,rep,name=map_value" json:"map_value,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *MapEntry) Reset()         { *m = MapEntry{} }
func (m *MapEntry) String() string { return proto.CompactTextString(m) }
func (*MapEntry) ProtoMessage()    {}

func (m *MapEntry) GetField() *MapField {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *MapEntry) GetCounterValue() int64 {
	if m != nil && m.CounterValue != nil {
		return *m.CounterValue
	}
	return 0
}

func (m *MapEntry) GetSetValue() [][]byte {
	if m != nil {
		return m.SetValue
	}
	return nil
}

func (m *MapEntry) GetRegisterValue() []byte {
	if m != nil {
		return m.RegisterValue
	}
	return nil
}

func (m *MapEntry) GetFlagValue() bool {
	if m != nil && m.FlagValue != nil {
		return *m.FlagValue
	}
	return false
}

func (m *MapEntry) GetMapValue() []*MapEntry {
	if m != nil {
		return m.MapValue
	}
	return nil
}

//
// The equivalent of KV's "RpbGetReq", results in a DtFetchResp. The
// request-time options are limited to ones that are relevant to
// structured data-types.
type DtFetchReq struct {
	// The identifier: bucket, key and bucket-type
	Bucket []byte `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key    []byte `protobuf:"bytes,2,req,name=key" json:"key,omitempty"`
	Type   []byte `protobuf:"bytes,3,req,name=type" json:"type,omitempty"`
	// Request options
	R            *uint32 `protobuf:"varint,4,opt,name=r" json:"r,omitempty"`
	Pr           *uint32 `protobuf:"varint,5,opt,name=pr" json:"pr,omitempty"`
	BasicQuorum  *bool   `protobuf:"varint,6,opt,name=basic_quorum" json:"basic_quorum,omitempty"`
	NotfoundOk   *bool   `protobuf:"varint,7,opt,name=notfound_ok" json:"notfound_ok,omitempty"`
	Timeout      *uint32 `protobuf:"varint,8,opt,name=timeout" json:"timeout,omitempty"`
	SloppyQuorum *bool   `protobuf:"varint,9,opt,name=sloppy_quorum" json:"sloppy_quorum,omitempty"`
	NVal         *uint32 `protobuf:"varint,10,opt,name=n_val" json:"n_val,omitempty"`
	// For read-only requests or context-free operations, you can set
	// this to false to reduce the size of the response payload.
	IncludeContext   *bool  `protobuf:"varint,11,opt,name=include_context,def=1" json:"include_context,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *DtFetchReq) Reset()         { *m = DtFetchReq{} }
func (m *DtFetchReq) String() string { return proto.CompactTextString(m) }
func (*DtFetchReq) ProtoMessage()    {}

const Default_DtFetchReq_IncludeContext bool = true

func (m *DtFetchReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *DtFetchReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DtFetchReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DtFetchReq) GetR() uint32 {
	if m != nil && m.R != nil {
		return *m.R
	}
	return 0
}

func (m *DtFetchReq) GetPr() uint32 {
	if m != nil && m.Pr != nil {
		return *m.Pr
	}
	return 0
}

func (m *DtFetchReq) GetBasicQuorum() bool {
	if m != nil && m.BasicQuorum != nil {
		return *m.BasicQuorum
	}
	return false
}

func (m *DtFetchReq) GetNotfoundOk() bool {
	if m != nil && m.NotfoundOk != nil {
		return *m.NotfoundOk
	}
	return false
}

func (m *DtFetchReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *DtFetchReq) GetSloppyQuorum() bool {
	if m != nil && m.SloppyQuorum != nil {
		return *m.SloppyQuorum
	}
	return false
}

func (m *DtFetchReq) GetNVal() uint32 {
	if m != nil && m.NVal != nil {
		return *m.NVal
	}
	return 0
}

func (m *DtFetchReq) GetIncludeContext() bool {
	if m != nil && m.IncludeContext != nil {
		return *m.IncludeContext
	}
	return Default_DtFetchReq_IncludeContext
}

//
// The value of the fetched data type. If present in the response,
// then empty values (sets, maps) should be treated as such.
type DtValue struct {
	CounterValue     *int64      `protobuf:"zigzag64,1,opt,name=counter_value" json:"counter_value,omitempty"`
	SetValue         [][]byte    `protobuf:"bytes,2,rep,name=set_value" json:"set_value,omitempty"`
	MapValue         []*MapEntry `protobuf:"bytes,3,rep,name=map_value" json:"map_value,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *DtValue) Reset()         { *m = DtValue{} }
func (m *DtValue) String() string { return proto.CompactTextString(m) }
func (*DtValue) ProtoMessage()    {}

func (m *DtValue) GetCounterValue() int64 {
	if m != nil && m.CounterValue != nil {
		return *m.CounterValue
	}
	return 0
}

func (m *DtValue) GetSetValue() [][]byte {
	if m != nil {
		return m.SetValue
	}
	return nil
}

func (m *DtValue) GetMapValue() []*MapEntry {
	if m != nil {
		return m.MapValue
	}
	return nil
}

//
// The response to a "Fetch" request. If the `include_context` option
// is specified, an opaque "context" value will be returned along with
// the user-friendly data. When sending an "Update" request, the
// client should send this context as well, similar to how one would
// send a vclock for KV updates. The `type` field indicates which
// value type to expect. When the `value` field is missing from the
// message, the client should interpret it as a "not found".
type DtFetchResp struct {
	Context          []byte                `protobuf:"bytes,1,opt,name=context" json:"context,omitempty"`
	Type             *DtFetchResp_DataType `protobuf:"varint,2,req,name=type,enum=rpbc.DtFetchResp_DataType" json:"type,omitempty"`
	Value            *DtValue              `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *DtFetchResp) Reset()         { *m = DtFetchResp{} }
func (m *DtFetchResp) String() string { return proto.CompactTextString(m) }
func (*DtFetchResp) ProtoMessage()    {}

func (m *DtFetchResp) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DtFetchResp) GetType() DtFetchResp_DataType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return DtFetchResp_COUNTER
}

func (m *DtFetchResp) GetValue() *DtValue {
	if m != nil {
		return m.Value
	}
	return nil
}

//
// An operation to update a Counter, either on its own or inside a
// Map. The `increment` field can be positive or negative. When absent,
// the meaning is an increment by 1.
type CounterOp struct {
	Increment        *int64 `protobuf:"zigzag64,1,opt,name=increment" json:"increment,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CounterOp) Reset()         { *m = CounterOp{} }
func (m *CounterOp) String() string { return proto.CompactTextString(m) }
func (*CounterOp) ProtoMessage()    {}

func (m *CounterOp) GetIncrement() int64 {
	if m != nil && m.Increment != nil {
		return *m.Increment
	}
	return 0
}

//
// An operation to update a Set, either on its own or inside a Map.
// Set members are opaque binary values, you can only add or remove
// them from a Set.
type SetOp struct {
	Adds             [][]byte `protobuf:"bytes,1,rep,name=adds" json:"adds,omitempty"`
	Removes          [][]byte `protobuf:"bytes,2,rep,name=removes" json:"removes,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *SetOp) Reset()         { *m = SetOp{} }
func (m *SetOp) String() string { return proto.CompactTextString(m) }
func (*SetOp) ProtoMessage()    {}

func (m *SetOp) GetAdds() [][]byte {
	if m != nil {
		return m.Adds
	}
	return nil
}

func (m *SetOp) GetRemoves() [][]byte {
	if m != nil {
		return m.Removes
	}
	return nil
}

//
// An operation to be applied to a value stored in a Map -- the
// contents of an UPDATE operation. The operation field that is
// present depends on the type of the field to which it is applied.
type MapUpdate struct {
	Field     *MapField  `protobuf:"bytes,1,req,name=field" json:"field,omitempty"`
	CounterOp *CounterOp `protobuf:"bytes,2,opt,name=counter_op" json:"counter_op,omitempty"`
	SetOp     *SetOp     `protobuf:"bytes,3,opt,name=set_op" json:"set_op,omitempty"`
	//
	// There is only one operation on a register, which is to set its
	// value, therefore the "operation" is the new value.
	RegisterOp       []byte            `protobuf:"bytes,4,opt,name=register_op" json:"register_op,omitempty"`
	FlagOp           *MapUpdate_FlagOp `protobuf:"varint,5,opt,name=flag_op,enum=rpbc.MapUpdate_FlagOp" json:"flag_op,omitempty"`
	MapOp            *MapOp            `protobuf:"bytes,6,opt,name=map_op" json:"map_op,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *MapUpdate) Reset()         { *m = MapUpdate{} }
func (m *MapUpdate) String() string { return proto.CompactTextString(m) }
func (*MapUpdate) ProtoMessage()    {}

func (m *MapUpdate) GetField() *MapField {
	if m != nil {
		return m.Field
	}
	return nil
}

func (m *MapUpdate) GetCounterOp() *CounterOp {
	if m != nil {
		return m.CounterOp
	}
	return nil
}

func (m *MapUpdate) GetSetOp() *SetOp {
	if m != nil {
		return m.SetOp
	}
	return nil
}

func (m *MapUpdate) GetRegisterOp() []byte {
	if m != nil {
		return m.RegisterOp
	}
	return nil
}

func (m *MapUpdate) GetFlagOp() MapUpdate_FlagOp {
	if m != nil && m.FlagOp != nil {
		return *m.FlagOp
	}
	return MapUpdate_ENABLE
}

func (m *MapUpdate) GetMapOp() *MapOp {
	if m != nil {
		return m.MapOp
	}
	return nil
}

//
// An operation to update a Map. All operations apply to individual
// fields in the Map.
type MapOp struct {
	//
	//  REMOVE removes a field and value from the Map.
	// UPDATE applies type-specific
	// operations to the values stored in the Map.
	Removes          []*MapField  `protobuf:"bytes,1,rep,name=removes" json:"removes,omitempty"`
	Updates          []*MapUpdate `protobuf:"bytes,2,rep,name=updates" json:"updates,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *MapOp) Reset()         { *m = MapOp{} }
func (m *MapOp) String() string { return proto.CompactTextString(m) }
func (*MapOp) ProtoMessage()    {}

func (m *MapOp) GetRemoves() []*MapField {
	if m != nil {
		return m.Removes
	}
	return nil
}

func (m *MapOp) GetUpdates() []*MapUpdate {
	if m != nil {
		return m.Updates
	}
	return nil
}

//
// A "union" type for update operations. The included operation
// depends on the datatype being updated.
type DtOp struct {
	CounterOp        *CounterOp `protobuf:"bytes,1,opt,name=counter_op" json:"counter_op,omitempty"`
	SetOp            *SetOp     `protobuf:"bytes,2,opt,name=set_op" json:"set_op,omitempty"`
	MapOp            *MapOp     `protobuf:"bytes,3,opt,name=map_op" json:"map_op,omitempty"`
	XXX_unrecognized []byte     `json:"-"`
}

func (m *DtOp) Reset()         { *m = DtOp{} }
func (m *DtOp) String() string { return proto.CompactTextString(m) }
func (*DtOp) ProtoMessage()    {}

func (m *DtOp) GetCounterOp() *CounterOp {
	if m != nil {
		return m.CounterOp
	}
	return nil
}

func (m *DtOp) GetSetOp() *SetOp {
	if m != nil {
		return m.SetOp
	}
	return nil
}

func (m *DtOp) GetMapOp() *MapOp {
	if m != nil {
		return m.MapOp
	}
	return nil
}

//
// The equivalent of KV's "RpbPutReq", results in an empty response or
// "DtUpdateResp" if `return_body` is specified, or the key is
// assigned by the server. The request-time options are limited to
// ones that are relevant to structured data-types.
type DtUpdateReq struct {
	// The identifier
	Bucket []byte `protobuf:"bytes,1,req,name=bucket" json:"bucket,omitempty"`
	Key    []byte `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
	Type   []byte `protobuf:"bytes,3,req,name=type" json:"type,omitempty"`
	// Opaque update-context
	Context []byte `protobuf:"bytes,4,opt,name=context" json:"context,omitempty"`
	// The operations
	Op *DtOp `protobuf:"bytes,5,req,name=op" json:"op,omitempty"`
	// Request options
	W                *uint32 `protobuf:"varint,6,opt,name=w" json:"w,omitempty"`
	Dw               *uint32 `protobuf:"varint,7,opt,name=dw" json:"dw,omitempty"`
	Pw               *uint32 `protobuf:"varint,8,opt,name=pw" json:"pw,omitempty"`
	ReturnBody       *bool   `protobuf:"varint,9,opt,name=return_body,def=0" json:"return_body,omitempty"`
	Timeout          *uint32 `protobuf:"varint,10,opt,name=timeout" json:"timeout,omitempty"`
	SloppyQuorum     *bool   `protobuf:"varint,11,opt,name=sloppy_quorum" json:"sloppy_quorum,omitempty"`
	NVal             *uint32 `protobuf:"varint,12,opt,name=n_val" json:"n_val,omitempty"`
	IncludeContext   *bool   `protobuf:"varint,13,opt,name=include_context,def=1" json:"include_context,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DtUpdateReq) Reset()         { *m = DtUpdateReq{} }
func (m *DtUpdateReq) String() string { return proto.CompactTextString(m) }
func (*DtUpdateReq) ProtoMessage()    {}

const Default_DtUpdateReq_ReturnBody bool = false
const Default_DtUpdateReq_IncludeContext bool = true

func (m *DtUpdateReq) GetBucket() []byte {
	if m != nil {
		return m.Bucket
	}
	return nil
}

func (m *DtUpdateReq) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DtUpdateReq) GetType() []byte {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DtUpdateReq) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DtUpdateReq) GetOp() *DtOp {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *DtUpdateReq) GetW() uint32 {
	if m != nil && m.W != nil {
		return *m.W
	}
	return 0
}

func (m *DtUpdateReq) GetDw() uint32 {
	if m != nil && m.Dw != nil {
		return *m.Dw
	}
	return 0
}

func (m *DtUpdateReq) GetPw() uint32 {
	if m != nil && m.Pw != nil {
		return *m.Pw
	}
	return 0
}

func (m *DtUpdateReq) GetReturnBody() bool {
	if m != nil && m.ReturnBody != nil {
		return *m.ReturnBody
	}
	return Default_DtUpdateReq_ReturnBody
}

func (m *DtUpdateReq) GetTimeout() uint32 {
	if m != nil && m.Timeout != nil {
		return *m.Timeout
	}
	return 0
}

func (m *DtUpdateReq) GetSloppyQuorum() bool {
	if m != nil && m.SloppyQuorum != nil {
		return *m.SloppyQuorum
	}
	return false
}

func (m *DtUpdateReq) GetNVal() uint32 {
	if m != nil && m.NVal != nil {
		return *m.NVal
	}
	return 0
}

func (m *DtUpdateReq) GetIncludeContext() bool {
	if m != nil && m.IncludeContext != nil {
		return *m.IncludeContext
	}
	return Default_DtUpdateReq_IncludeContext
}

//
// The equivalent of KV's "RpbPutResp", contains the assigned key if
// it was assigned by the server, and the resulting value and context
// if return_body was set.
type DtUpdateResp struct {
	// The key, if assigned by the server
	Key []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// The opaque update context and value, if return_body was set.
	Context          []byte      `protobuf:"bytes,2,opt,name=context" json:"context,omitempty"`
	CounterValue     *int64      `protobuf:"zigzag64,3,opt,name=counter_value" json:"counter_value,omitempty"`
	SetValue         [][]byte    `protobuf:"bytes,4,rep,name=set_value" json:"set_value,omitempty"`
	MapValue         []*MapEntry `protobuf:"bytes,5,rep,name=map_value" json:"map_value,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *DtUpdateResp) Reset()         { *m = DtUpdateResp{} }
func (m *DtUpdateResp) String() string { return proto.CompactTextString(m) }
func (*DtUpdateResp) ProtoMessage()    {}

func (m *DtUpdateResp) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *DtUpdateResp) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *DtUpdateResp) GetCounterValue() int64 {
	if m != nil && m.CounterValue != nil {
		return *m.CounterValue
	}
	return 0
}

func (m *DtUpdateResp) GetSetValue() [][]byte {
	if m != nil {
		return m.SetValue
	}
	return nil
}

func (m *DtUpdateResp) GetMapValue() []*MapEntry {
	if m != nil {
		return m.MapValue
	}
	return nil
}

func init() {
	proto.RegisterEnum("rpbc.MapField_MapFieldType", MapField_MapFieldType_name, MapField_MapFieldType_value)
	proto.RegisterEnum("rpbc.DtFetchResp_DataType", DtFetchResp_DataType_name, DtFetchResp_DataType_value)
	proto.RegisterEnum("rpbc.MapUpdate_FlagOp", MapUpdate_FlagOp_name, MapUpdate_FlagOp_value)
}
func (m *MapField) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Name = append(m.Name, data[index:postIndex]...)
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v MapField_MapFieldType
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (MapField_MapFieldType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *MapEntry) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.Field == nil {
				m.Field = &MapField{}
			}
			if err := m.Field.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field CounterValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.CounterValue = &v2
		case 3:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field SetValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.SetValue = append(m.SetValue, make([]byte, postIndex-index))
			copy(m.SetValue[len(m.SetValue)-1], data[index:postIndex])
			index = postIndex
		case 4:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field RegisterValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.RegisterValue = append(m.RegisterValue, data[index:postIndex]...)
			index = postIndex
		case 5:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field FlagValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.FlagValue = &b
		case 6:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field MapValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.MapValue = append(m.MapValue, &MapEntry{})
			m.MapValue[len(m.MapValue)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *DtFetchReq) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket, data[index:postIndex]...)
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, data[index:postIndex]...)
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Type = append(m.Type, data[index:postIndex]...)
			index = postIndex
		case 4:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field R", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.R = &v
		case 5:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Pr", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pr = &v
		case 6:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field BasicQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BasicQuorum = &b
		case 7:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field NotfoundOk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NotfoundOk = &b
		case 8:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 9:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field SloppyQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SloppyQuorum = &b
		case 10:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field NVal", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NVal = &v
		case 11:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field IncludeContext", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IncludeContext = &b
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *DtValue) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field CounterValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.CounterValue = &v2
		case 2:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field SetValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.SetValue = append(m.SetValue, make([]byte, postIndex-index))
			copy(m.SetValue[len(m.SetValue)-1], data[index:postIndex])
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field MapValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.MapValue = append(m.MapValue, &MapEntry{})
			m.MapValue[len(m.MapValue)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *DtFetchResp) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Context = append(m.Context, data[index:postIndex]...)
			index = postIndex
		case 2:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var v DtFetchResp_DataType
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (DtFetchResp_DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &v
		case 3:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &DtValue{}
			}
			if err := m.Value.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *CounterOp) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Increment", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.Increment = &v2
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *SetOp) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Adds", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Adds = append(m.Adds, make([]byte, postIndex-index))
			copy(m.Adds[len(m.Adds)-1], data[index:postIndex])
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Removes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Removes = append(m.Removes, make([]byte, postIndex-index))
			copy(m.Removes[len(m.Removes)-1], data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *MapUpdate) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Field", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.Field == nil {
				m.Field = &MapField{}
			}
			if err := m.Field.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field CounterOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.CounterOp == nil {
				m.CounterOp = &CounterOp{}
			}
			if err := m.CounterOp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field SetOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.SetOp == nil {
				m.SetOp = &SetOp{}
			}
			if err := m.SetOp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 4:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field RegisterOp", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.RegisterOp = append(m.RegisterOp, data[index:postIndex]...)
			index = postIndex
		case 5:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field FlagOp", wireType)
			}
			var v MapUpdate_FlagOp
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (MapUpdate_FlagOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FlagOp = &v
		case 6:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field MapOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.MapOp == nil {
				m.MapOp = &MapOp{}
			}
			if err := m.MapOp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *MapOp) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Removes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Removes = append(m.Removes, &MapField{})
			m.Removes[len(m.Removes)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Updates = append(m.Updates, &MapUpdate{})
			m.Updates[len(m.Updates)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *DtOp) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field CounterOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.CounterOp == nil {
				m.CounterOp = &CounterOp{}
			}
			if err := m.CounterOp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field SetOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.SetOp == nil {
				m.SetOp = &SetOp{}
			}
			if err := m.SetOp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field MapOp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.MapOp == nil {
				m.MapOp = &MapOp{}
			}
			if err := m.MapOp.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *DtUpdateReq) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Bucket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Bucket = append(m.Bucket, data[index:postIndex]...)
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, data[index:postIndex]...)
			index = postIndex
		case 3:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Type = append(m.Type, data[index:postIndex]...)
			index = postIndex
		case 4:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Context = append(m.Context, data[index:postIndex]...)
			index = postIndex
		case 5:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			if m.Op == nil {
				m.Op = &DtOp{}
			}
			if err := m.Op.Unmarshal(data[index:postIndex]); err != nil {
				return err
			}
			index = postIndex
		case 6:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.W = &v
		case 7:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Dw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dw = &v
		case 8:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Pw", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Pw = &v
		case 9:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field ReturnBody", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ReturnBody = &b
		case 10:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Timeout = &v
		case 11:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field SloppyQuorum", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.SloppyQuorum = &b
		case 12:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field NVal", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NVal = &v
		case 13:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field IncludeContext", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.IncludeContext = &b
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *DtUpdateResp) Unmarshal(data []byte) error {
	l := len(data)
	index := 0
	for index < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if index >= l {
				return io1.ErrUnexpectedEOF
			}
			b := data[index]
			index++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Key = append(m.Key, data[index:postIndex]...)
			index = postIndex
		case 2:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.Context = append(m.Context, data[index:postIndex]...)
			index = postIndex
		case 3:
			if wireType != 0 {
				return fmt1.Errorf("proto: wrong wireType = %d for field CounterValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			v = (v >> 1) ^ uint64((int64(v&1)<<63)>>63)
			v2 := int64(v)
			m.CounterValue = &v2
		case 4:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field SetValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + byteLen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.SetValue = append(m.SetValue, make([]byte, postIndex-index))
			copy(m.SetValue[len(m.SetValue)-1], data[index:postIndex])
			index = postIndex
		case 5:
			if wireType != 2 {
				return fmt1.Errorf("proto: wrong wireType = %d for field MapValue", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if index >= l {
					return io1.ErrUnexpectedEOF
				}
				b := data[index]
				index++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := index + msglen
			if postIndex > l {
				return io1.ErrUnexpectedEOF
			}
			m.MapValue = append(m.MapValue, &MapEntry{})
			m.MapValue[len(m.MapValue)-1].Unmarshal(data[index:postIndex])
			index = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			index -= sizeOfWire
			skippy, err := code_google_com_p_gogoprotobuf_proto1.Skip(data[index:])
			if err != nil {
				return err
			}
			if (index + skippy) > l {
				return io1.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[index:index+skippy]...)
			index += skippy
		}
	}
	return nil
}
func (m *MapField) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = len(m.Name)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovRiakDt(uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *MapEntry) Size() (n int) {
	var l int
	_ = l
	if m.Field != nil {
		l = m.Field.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.CounterValue != nil {
		n += 1 + sozRiakDt(uint64(*m.CounterValue))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.RegisterValue != nil {
		l = len(m.RegisterValue)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.FlagValue != nil {
		n += 2
	}
	if len(m.MapValue) > 0 {
		for _, e := range m.MapValue {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *DtFetchReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.R != nil {
		n += 1 + sovRiakDt(uint64(*m.R))
	}
	if m.Pr != nil {
		n += 1 + sovRiakDt(uint64(*m.Pr))
	}
	if m.BasicQuorum != nil {
		n += 2
	}
	if m.NotfoundOk != nil {
		n += 2
	}
	if m.Timeout != nil {
		n += 1 + sovRiakDt(uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		n += 2
	}
	if m.NVal != nil {
		n += 1 + sovRiakDt(uint64(*m.NVal))
	}
	if m.IncludeContext != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *DtValue) Size() (n int) {
	var l int
	_ = l
	if m.CounterValue != nil {
		n += 1 + sozRiakDt(uint64(*m.CounterValue))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if len(m.MapValue) > 0 {
		for _, e := range m.MapValue {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *DtFetchResp) Size() (n int) {
	var l int
	_ = l
	if m.Context != nil {
		l = len(m.Context)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Type != nil {
		n += 1 + sovRiakDt(uint64(*m.Type))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *CounterOp) Size() (n int) {
	var l int
	_ = l
	if m.Increment != nil {
		n += 1 + sozRiakDt(uint64(*m.Increment))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *SetOp) Size() (n int) {
	var l int
	_ = l
	if len(m.Adds) > 0 {
		for _, b := range m.Adds {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if len(m.Removes) > 0 {
		for _, b := range m.Removes {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *MapUpdate) Size() (n int) {
	var l int
	_ = l
	if m.Field != nil {
		l = m.Field.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.CounterOp != nil {
		l = m.CounterOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.SetOp != nil {
		l = m.SetOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.RegisterOp != nil {
		l = len(m.RegisterOp)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.FlagOp != nil {
		n += 1 + sovRiakDt(uint64(*m.FlagOp))
	}
	if m.MapOp != nil {
		l = m.MapOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *MapOp) Size() (n int) {
	var l int
	_ = l
	if len(m.Removes) > 0 {
		for _, e := range m.Removes {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if len(m.Updates) > 0 {
		for _, e := range m.Updates {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *DtOp) Size() (n int) {
	var l int
	_ = l
	if m.CounterOp != nil {
		l = m.CounterOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.SetOp != nil {
		l = m.SetOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.MapOp != nil {
		l = m.MapOp.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *DtUpdateReq) Size() (n int) {
	var l int
	_ = l
	if m.Bucket != nil {
		l = len(m.Bucket)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Type != nil {
		l = len(m.Type)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Context != nil {
		l = len(m.Context)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Op != nil {
		l = m.Op.Size()
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.W != nil {
		n += 1 + sovRiakDt(uint64(*m.W))
	}
	if m.Dw != nil {
		n += 1 + sovRiakDt(uint64(*m.Dw))
	}
	if m.Pw != nil {
		n += 1 + sovRiakDt(uint64(*m.Pw))
	}
	if m.ReturnBody != nil {
		n += 2
	}
	if m.Timeout != nil {
		n += 1 + sovRiakDt(uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		n += 2
	}
	if m.NVal != nil {
		n += 1 + sovRiakDt(uint64(*m.NVal))
	}
	if m.IncludeContext != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}
func (m *DtUpdateResp) Size() (n int) {
	var l int
	_ = l
	if m.Key != nil {
		l = len(m.Key)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.Context != nil {
		l = len(m.Context)
		n += 1 + l + sovRiakDt(uint64(l))
	}
	if m.CounterValue != nil {
		n += 1 + sozRiakDt(uint64(*m.CounterValue))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			l = len(b)
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if len(m.MapValue) > 0 {
		for _, e := range m.MapValue {
			l = e.Size()
			n += 1 + l + sovRiakDt(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRiakDt(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRiakDt(x uint64) (n int) {
	return sovRiakDt(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func NewPopulatedMapField(r randyRiakDt, easy bool) *MapField {
	this := &MapField{}
	v1 := r.Intn(100)
	this.Name = make([]byte, v1)
	for i := 0; i < v1; i++ {
		this.Name[i] = byte(r.Intn(256))
	}
	v2 := MapField_MapFieldType([]int32{1, 2, 3, 4, 5}[r.Intn(5)])
	this.Type = &v2
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 3)
	}
	return this
}

func NewPopulatedMapEntry(r randyRiakDt, easy bool) *MapEntry {
	this := &MapEntry{}
	this.Field = NewPopulatedMapField(r, easy)
	if r.Intn(10) != 0 {
		v3 := r.Int63()
		if r.Intn(2) == 0 {
			v3 *= -1
		}
		this.CounterValue = &v3
	}
	if r.Intn(10) != 0 {
		v4 := r.Intn(100)
		this.SetValue = make([][]byte, v4)
		for i := 0; i < v4; i++ {
			v5 := r.Intn(100)
			this.SetValue[i] = make([]byte, v5)
			for j := 0; j < v5; j++ {
				this.SetValue[i][j] = byte(r.Intn(256))
			}
		}
	}
	if r.Intn(10) != 0 {
		v6 := r.Intn(100)
		this.RegisterValue = make([]byte, v6)
		for i := 0; i < v6; i++ {
			this.RegisterValue[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		v7 := bool(r.Intn(2) == 0)
		this.FlagValue = &v7
	}
	if r.Intn(10) != 0 {
		v8 := r.Intn(10)
		this.MapValue = make([]*MapEntry, v8)
		for i := 0; i < v8; i++ {
			this.MapValue[i] = NewPopulatedMapEntry(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 7)
	}
	return this
}

func NewPopulatedDtFetchReq(r randyRiakDt, easy bool) *DtFetchReq {
	this := &DtFetchReq{}
	v9 := r.Intn(100)
	this.Bucket = make([]byte, v9)
	for i := 0; i < v9; i++ {
		this.Bucket[i] = byte(r.Intn(256))
	}
	v10 := r.Intn(100)
	this.Key = make([]byte, v10)
	for i := 0; i < v10; i++ {
		this.Key[i] = byte(r.Intn(256))
	}
	v11 := r.Intn(100)
	this.Type = make([]byte, v11)
	for i := 0; i < v11; i++ {
		this.Type[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v12 := r.Uint32()
		this.R = &v12
	}
	if r.Intn(10) != 0 {
		v13 := r.Uint32()
		this.Pr = &v13
	}
	if r.Intn(10) != 0 {
		v14 := bool(r.Intn(2) == 0)
		this.BasicQuorum = &v14
	}
	if r.Intn(10) != 0 {
		v15 := bool(r.Intn(2) == 0)
		this.NotfoundOk = &v15
	}
	if r.Intn(10) != 0 {
		v16 := r.Uint32()
		this.Timeout = &v16
	}
	if r.Intn(10) != 0 {
		v17 := bool(r.Intn(2) == 0)
		this.SloppyQuorum = &v17
	}
	if r.Intn(10) != 0 {
		v18 := r.Uint32()
		this.NVal = &v18
	}
	if r.Intn(10) != 0 {
		v19 := bool(r.Intn(2) == 0)
		this.IncludeContext = &v19
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 12)
	}
	return this
}

func NewPopulatedDtValue(r randyRiakDt, easy bool) *DtValue {
	this := &DtValue{}
	if r.Intn(10) != 0 {
		v20 := r.Int63()
		if r.Intn(2) == 0 {
			v20 *= -1
		}
		this.CounterValue = &v20
	}
	if r.Intn(10) != 0 {
		v21 := r.Intn(100)
		this.SetValue = make([][]byte, v21)
		for i := 0; i < v21; i++ {
			v22 := r.Intn(100)
			this.SetValue[i] = make([]byte, v22)
			for j := 0; j < v22; j++ {
				this.SetValue[i][j] = byte(r.Intn(256))
			}
		}
	}
	if r.Intn(10) != 0 {
		v23 := r.Intn(10)
		this.MapValue = make([]*MapEntry, v23)
		for i := 0; i < v23; i++ {
			this.MapValue[i] = NewPopulatedMapEntry(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 4)
	}
	return this
}

func NewPopulatedDtFetchResp(r randyRiakDt, easy bool) *DtFetchResp {
	this := &DtFetchResp{}
	if r.Intn(10) != 0 {
		v24 := r.Intn(100)
		this.Context = make([]byte, v24)
		for i := 0; i < v24; i++ {
			this.Context[i] = byte(r.Intn(256))
		}
	}
	v25 := DtFetchResp_DataType([]int32{1, 2, 3}[r.Intn(3)])
	this.Type = &v25
	if r.Intn(10) != 0 {
		this.Value = NewPopulatedDtValue(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 4)
	}
	return this
}

func NewPopulatedCounterOp(r randyRiakDt, easy bool) *CounterOp {
	this := &CounterOp{}
	if r.Intn(10) != 0 {
		v26 := r.Int63()
		if r.Intn(2) == 0 {
			v26 *= -1
		}
		this.Increment = &v26
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 2)
	}
	return this
}

func NewPopulatedSetOp(r randyRiakDt, easy bool) *SetOp {
	this := &SetOp{}
	if r.Intn(10) != 0 {
		v27 := r.Intn(100)
		this.Adds = make([][]byte, v27)
		for i := 0; i < v27; i++ {
			v28 := r.Intn(100)
			this.Adds[i] = make([]byte, v28)
			for j := 0; j < v28; j++ {
				this.Adds[i][j] = byte(r.Intn(256))
			}
		}
	}
	if r.Intn(10) != 0 {
		v29 := r.Intn(100)
		this.Removes = make([][]byte, v29)
		for i := 0; i < v29; i++ {
			v30 := r.Intn(100)
			this.Removes[i] = make([]byte, v30)
			for j := 0; j < v30; j++ {
				this.Removes[i][j] = byte(r.Intn(256))
			}
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 3)
	}
	return this
}

func NewPopulatedMapUpdate(r randyRiakDt, easy bool) *MapUpdate {
	this := &MapUpdate{}
	this.Field = NewPopulatedMapField(r, easy)
	if r.Intn(10) != 0 {
		this.CounterOp = NewPopulatedCounterOp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.SetOp = NewPopulatedSetOp(r, easy)
	}
	if r.Intn(10) != 0 {
		v31 := r.Intn(100)
		this.RegisterOp = make([]byte, v31)
		for i := 0; i < v31; i++ {
			this.RegisterOp[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		v32 := MapUpdate_FlagOp([]int32{1, 2}[r.Intn(2)])
		this.FlagOp = &v32
	}
	if r.Intn(10) != 0 {
		this.MapOp = NewPopulatedMapOp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 7)
	}
	return this
}

func NewPopulatedMapOp(r randyRiakDt, easy bool) *MapOp {
	this := &MapOp{}
	if r.Intn(10) != 0 {
		v33 := r.Intn(10)
		this.Removes = make([]*MapField, v33)
		for i := 0; i < v33; i++ {
			this.Removes[i] = NewPopulatedMapField(r, easy)
		}
	}
	if r.Intn(10) != 0 {
		v34 := r.Intn(10)
		this.Updates = make([]*MapUpdate, v34)
		for i := 0; i < v34; i++ {
			this.Updates[i] = NewPopulatedMapUpdate(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 3)
	}
	return this
}

func NewPopulatedDtOp(r randyRiakDt, easy bool) *DtOp {
	this := &DtOp{}
	if r.Intn(10) != 0 {
		this.CounterOp = NewPopulatedCounterOp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.SetOp = NewPopulatedSetOp(r, easy)
	}
	if r.Intn(10) != 0 {
		this.MapOp = NewPopulatedMapOp(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 4)
	}
	return this
}

func NewPopulatedDtUpdateReq(r randyRiakDt, easy bool) *DtUpdateReq {
	this := &DtUpdateReq{}
	v35 := r.Intn(100)
	this.Bucket = make([]byte, v35)
	for i := 0; i < v35; i++ {
		this.Bucket[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v36 := r.Intn(100)
		this.Key = make([]byte, v36)
		for i := 0; i < v36; i++ {
			this.Key[i] = byte(r.Intn(256))
		}
	}
	v37 := r.Intn(100)
	this.Type = make([]byte, v37)
	for i := 0; i < v37; i++ {
		this.Type[i] = byte(r.Intn(256))
	}
	if r.Intn(10) != 0 {
		v38 := r.Intn(100)
		this.Context = make([]byte, v38)
		for i := 0; i < v38; i++ {
			this.Context[i] = byte(r.Intn(256))
		}
	}
	this.Op = NewPopulatedDtOp(r, easy)
	if r.Intn(10) != 0 {
		v39 := r.Uint32()
		this.W = &v39
	}
	if r.Intn(10) != 0 {
		v40 := r.Uint32()
		this.Dw = &v40
	}
	if r.Intn(10) != 0 {
		v41 := r.Uint32()
		this.Pw = &v41
	}
	if r.Intn(10) != 0 {
		v42 := bool(r.Intn(2) == 0)
		this.ReturnBody = &v42
	}
	if r.Intn(10) != 0 {
		v43 := r.Uint32()
		this.Timeout = &v43
	}
	if r.Intn(10) != 0 {
		v44 := bool(r.Intn(2) == 0)
		this.SloppyQuorum = &v44
	}
	if r.Intn(10) != 0 {
		v45 := r.Uint32()
		this.NVal = &v45
	}
	if r.Intn(10) != 0 {
		v46 := bool(r.Intn(2) == 0)
		this.IncludeContext = &v46
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 14)
	}
	return this
}

func NewPopulatedDtUpdateResp(r randyRiakDt, easy bool) *DtUpdateResp {
	this := &DtUpdateResp{}
	if r.Intn(10) != 0 {
		v47 := r.Intn(100)
		this.Key = make([]byte, v47)
		for i := 0; i < v47; i++ {
			this.Key[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		v48 := r.Intn(100)
		this.Context = make([]byte, v48)
		for i := 0; i < v48; i++ {
			this.Context[i] = byte(r.Intn(256))
		}
	}
	if r.Intn(10) != 0 {
		v49 := r.Int63()
		if r.Intn(2) == 0 {
			v49 *= -1
		}
		this.CounterValue = &v49
	}
	if r.Intn(10) != 0 {
		v50 := r.Intn(100)
		this.SetValue = make([][]byte, v50)
		for i := 0; i < v50; i++ {
			v51 := r.Intn(100)
			this.SetValue[i] = make([]byte, v51)
			for j := 0; j < v51; j++ {
				this.SetValue[i][j] = byte(r.Intn(256))
			}
		}
	}
	if r.Intn(10) != 0 {
		v52 := r.Intn(10)
		this.MapValue = make([]*MapEntry, v52)
		for i := 0; i < v52; i++ {
			this.MapValue[i] = NewPopulatedMapEntry(r, easy)
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedRiakDt(r, 6)
	}
	return this
}

type randyRiakDt interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneRiakDt(r randyRiakDt) rune {
	res := rune(r.Uint32() % 1112064)
	if 55296 <= res {
		res += 2047
	}
	return res
}
func randStringRiakDt(r randyRiakDt) string {
	v53 := r.Intn(100)
	tmps := make([]rune, v53)
	for i := 0; i < v53; i++ {
		tmps[i] = randUTF8RuneRiakDt(r)
	}
	return string(tmps)
}
func randUnrecognizedRiakDt(r randyRiakDt, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldRiakDt(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldRiakDt(data []byte, r randyRiakDt, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateRiakDt(data, uint64(key))
		v54 := r.Int63()
		if r.Intn(2) == 0 {
			v54 *= -1
		}
		data = encodeVarintPopulateRiakDt(data, uint64(v54))
	case 1:
		data = encodeVarintPopulateRiakDt(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateRiakDt(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateRiakDt(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateRiakDt(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateRiakDt(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *MapField) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MapField) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if m.Type != nil {
		data[i] = 0x10
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *MapEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MapEntry) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.Field.Size()))
		n1, err := m.Field.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.CounterValue != nil {
		data[i] = 0x10
		i++
		i = encodeVarintRiakDt(data, i, uint64((uint64(*m.CounterValue)<<1)^uint64((*m.CounterValue>>63))))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			data[i] = 0x1a
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.RegisterValue != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.RegisterValue)))
		i += copy(data[i:], m.RegisterValue)
	}
	if m.FlagValue != nil {
		data[i] = 0x28
		i++
		if *m.FlagValue {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.MapValue) > 0 {
		for _, msg := range m.MapValue {
			data[i] = 0x32
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *DtFetchReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtFetchReq) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Type != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.R != nil {
		data[i] = 0x20
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.R))
	}
	if m.Pr != nil {
		data[i] = 0x28
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Pr))
	}
	if m.BasicQuorum != nil {
		data[i] = 0x30
		i++
		if *m.BasicQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NotfoundOk != nil {
		data[i] = 0x38
		i++
		if *m.NotfoundOk {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Timeout != nil {
		data[i] = 0x40
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		data[i] = 0x48
		i++
		if *m.SloppyQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NVal != nil {
		data[i] = 0x50
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.NVal))
	}
	if m.IncludeContext != nil {
		data[i] = 0x58
		i++
		if *m.IncludeContext {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *DtValue) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtValue) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CounterValue != nil {
		data[i] = 0x8
		i++
		i = encodeVarintRiakDt(data, i, uint64((uint64(*m.CounterValue)<<1)^uint64((*m.CounterValue>>63))))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			data[i] = 0x12
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.MapValue) > 0 {
		for _, msg := range m.MapValue {
			data[i] = 0x1a
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *DtFetchResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtFetchResp) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Context != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Context)))
		i += copy(data[i:], m.Context)
	}
	if m.Type != nil {
		data[i] = 0x10
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Type))
	}
	if m.Value != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.Value.Size()))
		n2, err := m.Value.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *CounterOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CounterOp) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Increment != nil {
		data[i] = 0x8
		i++
		i = encodeVarintRiakDt(data, i, uint64((uint64(*m.Increment)<<1)^uint64((*m.Increment>>63))))
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *SetOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetOp) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Adds) > 0 {
		for _, b := range m.Adds {
			data[i] = 0xa
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.Removes) > 0 {
		for _, b := range m.Removes {
			data[i] = 0x12
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *MapUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MapUpdate) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Field != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.Field.Size()))
		n3, err := m.Field.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.CounterOp != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.CounterOp.Size()))
		n4, err := m.CounterOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.SetOp != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.SetOp.Size()))
		n5, err := m.SetOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.RegisterOp != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.RegisterOp)))
		i += copy(data[i:], m.RegisterOp)
	}
	if m.FlagOp != nil {
		data[i] = 0x28
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.FlagOp))
	}
	if m.MapOp != nil {
		data[i] = 0x32
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.MapOp.Size()))
		n6, err := m.MapOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *MapOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *MapOp) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Removes) > 0 {
		for _, msg := range m.Removes {
			data[i] = 0xa
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Updates) > 0 {
		for _, msg := range m.Updates {
			data[i] = 0x12
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *DtOp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtOp) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CounterOp != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.CounterOp.Size()))
		n7, err := m.CounterOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.SetOp != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.SetOp.Size()))
		n8, err := m.SetOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.MapOp != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.MapOp.Size()))
		n9, err := m.MapOp.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *DtUpdateReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtUpdateReq) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Bucket != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Bucket)))
		i += copy(data[i:], m.Bucket)
	}
	if m.Key != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Type != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Type)))
		i += copy(data[i:], m.Type)
	}
	if m.Context != nil {
		data[i] = 0x22
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Context)))
		i += copy(data[i:], m.Context)
	}
	if m.Op != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintRiakDt(data, i, uint64(m.Op.Size()))
		n10, err := m.Op.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.W != nil {
		data[i] = 0x30
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.W))
	}
	if m.Dw != nil {
		data[i] = 0x38
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Dw))
	}
	if m.Pw != nil {
		data[i] = 0x40
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Pw))
	}
	if m.ReturnBody != nil {
		data[i] = 0x48
		i++
		if *m.ReturnBody {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Timeout != nil {
		data[i] = 0x50
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.Timeout))
	}
	if m.SloppyQuorum != nil {
		data[i] = 0x58
		i++
		if *m.SloppyQuorum {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.NVal != nil {
		data[i] = 0x60
		i++
		i = encodeVarintRiakDt(data, i, uint64(*m.NVal))
	}
	if m.IncludeContext != nil {
		data[i] = 0x68
		i++
		if *m.IncludeContext {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func (m *DtUpdateResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DtUpdateResp) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Key != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Key)))
		i += copy(data[i:], m.Key)
	}
	if m.Context != nil {
		data[i] = 0x12
		i++
		i = encodeVarintRiakDt(data, i, uint64(len(m.Context)))
		i += copy(data[i:], m.Context)
	}
	if m.CounterValue != nil {
		data[i] = 0x18
		i++
		i = encodeVarintRiakDt(data, i, uint64((uint64(*m.CounterValue)<<1)^uint64((*m.CounterValue>>63))))
	}
	if len(m.SetValue) > 0 {
		for _, b := range m.SetValue {
			data[i] = 0x22
			i++
			i = encodeVarintRiakDt(data, i, uint64(len(b)))
			i += copy(data[i:], b)
		}
	}
	if len(m.MapValue) > 0 {
		for _, msg := range m.MapValue {
			data[i] = 0x2a
			i++
			i = encodeVarintRiakDt(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}
func encodeFixed64RiakDt(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32RiakDt(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRiakDt(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (this *MapField) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MapField)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes1.Equal(this.Name, that1.Name) {
		return false
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MapEntry) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MapEntry)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Field.Equal(that1.Field) {
		return false
	}
	if this.CounterValue != nil && that1.CounterValue != nil {
		if *this.CounterValue != *that1.CounterValue {
			return false
		}
	} else if this.CounterValue != nil {
		return false
	} else if that1.CounterValue != nil {
		return false
	}
	if len(this.SetValue) != len(that1.SetValue) {
		return false
	}
	for i := range this.SetValue {
		if !bytes1.Equal(this.SetValue[i], that1.SetValue[i]) {
			return false
		}
	}
	if !bytes1.Equal(this.RegisterValue, that1.RegisterValue) {
		return false
	}
	if this.FlagValue != nil && that1.FlagValue != nil {
		if *this.FlagValue != *that1.FlagValue {
			return false
		}
	} else if this.FlagValue != nil {
		return false
	} else if that1.FlagValue != nil {
		return false
	}
	if len(this.MapValue) != len(that1.MapValue) {
		return false
	}
	for i := range this.MapValue {
		if !this.MapValue[i].Equal(that1.MapValue[i]) {
			return false
		}
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DtFetchReq) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DtFetchReq)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes1.Equal(this.Bucket, that1.Bucket) {
		return false
	}
	if !bytes1.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes1.Equal(this.Type, that1.Type) {
		return false
	}
	if this.R != nil && that1.R != nil {
		if *this.R != *that1.R {
			return false
		}
	} else if this.R != nil {
		return false
	} else if that1.R != nil {
		return false
	}
	if this.Pr != nil && that1.Pr != nil {
		if *this.Pr != *that1.Pr {
			return false
		}
	} else if this.Pr != nil {
		return false
	} else if that1.Pr != nil {
		return false
	}
	if this.BasicQuorum != nil && that1.BasicQuorum != nil {
		if *this.BasicQuorum != *that1.BasicQuorum {
			return false
		}
	} else if this.BasicQuorum != nil {
		return false
	} else if that1.BasicQuorum != nil {
		return false
	}
	if this.NotfoundOk != nil && that1.NotfoundOk != nil {
		if *this.NotfoundOk != *that1.NotfoundOk {
			return false
		}
	} else if this.NotfoundOk != nil {
		return false
	} else if that1.NotfoundOk != nil {
		return false
	}
	if this.Timeout != nil && that1.Timeout != nil {
		if *this.Timeout != *that1.Timeout {
			return false
		}
	} else if this.Timeout != nil {
		return false
	} else if that1.Timeout != nil {
		return false
	}
	if this.SloppyQuorum != nil && that1.SloppyQuorum != nil {
		if *this.SloppyQuorum != *that1.SloppyQuorum {
			return false
		}
	} else if this.SloppyQuorum != nil {
		return false
	} else if that1.SloppyQuorum != nil {
		return false
	}
	if this.NVal != nil && that1.NVal != nil {
		if *this.NVal != *that1.NVal {
			return false
		}
	} else if this.NVal != nil {
		return false
	} else if that1.NVal != nil {
		return false
	}
	if this.IncludeContext != nil && that1.IncludeContext != nil {
		if *this.IncludeContext != *that1.IncludeContext {
			return false
		}
	} else if this.IncludeContext != nil {
		return false
	} else if that1.IncludeContext != nil {
		return false
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DtValue) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DtValue)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.CounterValue != nil && that1.CounterValue != nil {
		if *this.CounterValue != *that1.CounterValue {
			return false
		}
	} else if this.CounterValue != nil {
		return false
	} else if that1.CounterValue != nil {
		return false
	}
	if len(this.SetValue) != len(that1.SetValue) {
		return false
	}
	for i := range this.SetValue {
		if !bytes1.Equal(this.SetValue[i], that1.SetValue[i]) {
			return false
		}
	}
	if len(this.MapValue) != len(that1.MapValue) {
		return false
	}
	for i := range this.MapValue {
		if !this.MapValue[i].Equal(that1.MapValue[i]) {
			return false
		}
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DtFetchResp) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DtFetchResp)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes1.Equal(this.Context, that1.Context) {
		return false
	}
	if this.Type != nil && that1.Type != nil {
		if *this.Type != *that1.Type {
			return false
		}
	} else if this.Type != nil {
		return false
	} else if that1.Type != nil {
		return false
	}
	if !this.Value.Equal(that1.Value) {
		return false
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CounterOp) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CounterOp)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.Increment != nil && that1.Increment != nil {
		if *this.Increment != *that1.Increment {
			return false
		}
	} else if this.Increment != nil {
		return false
	} else if that1.Increment != nil {
		return false
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *SetOp) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*SetOp)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Adds) != len(that1.Adds) {
		return false
	}
	for i := range this.Adds {
		if !bytes1.Equal(this.Adds[i], that1.Adds[i]) {
			return false
		}
	}
	if len(this.Removes) != len(that1.Removes) {
		return false
	}
	for i := range this.Removes {
		if !bytes1.Equal(this.Removes[i], that1.Removes[i]) {
			return false
		}
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MapUpdate) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MapUpdate)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Field.Equal(that1.Field) {
		return false
	}
	if !this.CounterOp.Equal(that1.CounterOp) {
		return false
	}
	if !this.SetOp.Equal(that1.SetOp) {
		return false
	}
	if !bytes1.Equal(this.RegisterOp, that1.RegisterOp) {
		return false
	}
	if this.FlagOp != nil && that1.FlagOp != nil {
		if *this.FlagOp != *that1.FlagOp {
			return false
		}
	} else if this.FlagOp != nil {
		return false
	} else if that1.FlagOp != nil {
		return false
	}
	if !this.MapOp.Equal(that1.MapOp) {
		return false
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MapOp) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MapOp)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Removes) != len(that1.Removes) {
		return false
	}
	for i := range this.Removes {
		if !this.Removes[i].Equal(that1.Removes[i]) {
			return false
		}
	}
	if len(this.Updates) != len(that1.Updates) {
		return false
	}
	for i := range this.Updates {
		if !this.Updates[i].Equal(that1.Updates[i]) {
			return false
		}
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DtOp) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DtOp)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.CounterOp.Equal(that1.CounterOp) {
		return false
	}
	if !this.SetOp.Equal(that1.SetOp) {
		return false
	}
	if !this.MapOp.Equal(that1.MapOp) {
		return false
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DtUpdateReq) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DtUpdateReq)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes1.Equal(this.Bucket, that1.Bucket) {
		return false
	}
	if !bytes1.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes1.Equal(this.Type, that1.Type) {
		return false
	}
	if !bytes1.Equal(this.Context, that1.Context) {
		return false
	}
	if !this.Op.Equal(that1.Op) {
		return false
	}
	if this.W != nil && that1.W != nil {
		if *this.W != *that1.W {
			return false
		}
	} else if this.W != nil {
		return false
	} else if that1.W != nil {
		return false
	}
	if this.Dw != nil && that1.Dw != nil {
		if *this.Dw != *that1.Dw {
			return false
		}
	} else if this.Dw != nil {
		return false
	} else if that1.Dw != nil {
		return false
	}
	if this.Pw != nil && that1.Pw != nil {
		if *this.Pw != *that1.Pw {
			return false
		}
	} else if this.Pw != nil {
		return false
	} else if that1.Pw != nil {
		return false
	}
	if this.ReturnBody != nil && that1.ReturnBody != nil {
		if *this.ReturnBody != *that1.ReturnBody {
			return false
		}
	} else if this.ReturnBody != nil {
		return false
	} else if that1.ReturnBody != nil {
		return false
	}
	if this.Timeout != nil && that1.Timeout != nil {
		if *this.Timeout != *that1.Timeout {
			return false
		}
	} else if this.Timeout != nil {
		return false
	} else if that1.Timeout != nil {
		return false
	}
	if this.SloppyQuorum != nil && that1.SloppyQuorum != nil {
		if *this.SloppyQuorum != *that1.SloppyQuorum {
			return false
		}
	} else if this.SloppyQuorum != nil {
		return false
	} else if that1.SloppyQuorum != nil {
		return false
	}
	if this.NVal != nil && that1.NVal != nil {
		if *this.NVal != *that1.NVal {
			return false
		}
	} else if this.NVal != nil {
		return false
	} else if that1.NVal != nil {
		return false
	}
	if this.IncludeContext != nil && that1.IncludeContext != nil {
		if *this.IncludeContext != *that1.IncludeContext {
			return false
		}
	} else if this.IncludeContext != nil {
		return false
	} else if that1.IncludeContext != nil {
		return false
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *DtUpdateResp) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*DtUpdateResp)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes1.Equal(this.Key, that1.Key) {
		return false
	}
	if !bytes1.Equal(this.Context, that1.Context) {
		return false
	}
	if this.CounterValue != nil && that1.CounterValue != nil {
		if *this.CounterValue != *that1.CounterValue {
			return false
		}
	} else if this.CounterValue != nil {
		return false
	} else if that1.CounterValue != nil {
		return false
	}
	if len(this.SetValue) != len(that1.SetValue) {
		return false
	}
	for i := range this.SetValue {
		if !bytes1.Equal(this.SetValue[i], that1.SetValue[i]) {
			return false
		}
	}
	if len(this.MapValue) != len(that1.MapValue) {
		return false
	}
	for i := range this.MapValue {
		if !this.MapValue[i].Equal(that1.MapValue[i]) {
			return false
		}
	}
	if !bytes1.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
